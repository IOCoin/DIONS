// Copyright (c) 2018 The I/O Coin developers
//
//
#include "db.h"
#include "txdb-leveldb.h"
#include "keystore.h"
#include "wallet.h"
#include "init.h"
#include "base_reflect.h"
#include "uint256.h"

#include "bitcoinrpc.h"
#include "main.h"
#include "ptrie/TrieDB.h"
#include "ptrie/StateCacheDB.h"
#include "ptrie/OverlayDB.h"
#include "ptrie/Address.h"
#include "ptrie/Account.h"
#include "ptrie/DBFactory.h"
#include "state.h"
#include "json/json_spirit_reader_template.h"
#include "json/json_spirit_writer_template.h"
#include "json/json_spirit_utils.h"
#include <boost/xpressive/xpressive_dynamic.hpp>
#include <boost/filesystem.hpp>
#include <stdlib.h>
#include <stdio.h>
#include <fstream>
#include <iostream>
#include <sstream>
#include <boost/program_options.hpp>
#include <boost/program_options/options_description.hpp>
#include <boost/iostreams/filtering_streambuf.hpp>
#include <boost/iostreams/filtering_stream.hpp>
#include <boost/iostreams/copy.hpp>
#include <boost/iostreams/filter/zlib.hpp>
#include <boost/filesystem.hpp>
#include <boost/iostreams/stream.hpp>
#include <boost/iostreams/filter/gzip.hpp>
#include <boost/iostreams/device/file_descriptor.hpp>
#include <dvmone/dvmone.h>
#include <dvmc/transitional_node.hpp>
#include <dvmc/dvmc.h>
#include <dvmc/dvmc.hpp>
#include <dvmc/hex.hpp>
#include <dvmc/loader.h>
#include <dvmc/tooling.hpp>
#include <fstream>
#include <boost/foreach.hpp>
#include <boost/tokenizer.hpp>
#include <boost/archive/text_iarchive.hpp>
#include <boost/archive/text_oarchive.hpp>

using namespace std;
using dvmc::operator""_address;
using namespace json_spirit;
using namespace std;
using namespace json_spirit;
using namespace boost::iostreams;

namespace fs = boost::filesystem;

extern LocatorNodeDB* ln1Db;
extern bool aliasTx(LocatorNodeDB& aliasCacheDB, const vector<unsigned char> &vchPath, CTransaction& tx);
extern unsigned int scaleMonitor();
extern string txRelay(const CScript& scriptPubKey, int64_t nValue, const __wx__Tx& wtxIn, __wx__Tx& wtxNew, bool fAskFee);
extern bool aliasAddress(const CTransaction& tx, std::string& strAddress);
extern Object JSONRPCError(int code, const string& message);
extern Value xtu_url__(const string& url);
dev::OverlayDB* overlayDB_;
template<typename T> void ConvertTo(Value& value, bool fAllowNull=false);

std::map<vchType, uint256> mapMyMessages_cycle;
std::map<vchType, uint256> mapLocator_cycle;
std::map<vchType, set<uint256> > mapState_cycle;
std::map<vchType, set<uint256> > k1Export_cycle;

#ifdef GUI
extern std::map<uint160, vchType> mapLocatorHashes;
#endif

#ifdef LL_RELAY_BASE__
#define mul_mod(a,b,m) (( (long long) (a) * (long long) (b) ) % (m))
#else
#define mul_mod(a,b,m) fmod( (double) a * (double) b, m)
#endif


//Ext frame
typedef struct vx_bytes32
{
    //The 32 bytes.
    uint8_t bytes[32];
} vx_bytes32;

typedef struct vx_bytes32 evmc_uint256be;

//VX

extern vchType vchFromValue(const Value& value);
extern vchType vchFromString(const std::string& str);
extern string stringFromVch(const vector<unsigned char> &vch);

bool searchPathEncrypted2(string l, uint256& wtxInHash);

extern int GetTxPosHeight(PathIndex& txPos);
extern int GetTxPosHeight(CDiskTxPos& txPos);
int aliasHeight(vector<unsigned char> vchPath);

bool vertex_serial_n_cycle(const string& origin, const string& data, __wx__Tx& serial_n)
{
    string locatorStr = origin;
    string indexStr = data;

    if(isOnlyWhiteSpace(locatorStr))
    {
        string err = "Attempt to register alias consisting only of white space";

        throw JSONRPCError(RPC_WALLET_ERROR, err);
    }
    else if(locatorStr.size() > 255)
    {
        string err = "Attempt to register alias more than 255 chars";

        throw JSONRPCError(RPC_WALLET_ERROR, err);
    }

    uint256 wtxInHash__;

    vector<Value> res;
    LocatorNodeDB aliasCacheDB("r");
    CTransaction tx;
    if(aliasTx(aliasCacheDB, vchFromString(locatorStr), tx))
    {
        string err = "Attempt to register alias : " + locatorStr + ", this alias is already active with tx " + tx.GetHash().GetHex();

        throw JSONRPCError(RPC_WALLET_ERROR, err);
    }

    CPubKey vchPubKey;
    CReserveKey reservekey(pwalletMain);
    if(!reservekey.GetReservedKey(vchPubKey))
    {
        return false;
    }

    reservekey.KeepKey();

    cba keyAddress(vchPubKey.GetID());
    CKeyID keyID;
    keyAddress.GetKeyID(keyID);
    pwalletMain->SetAddressBookName(keyID, "");

    __wx__DB walletdb(pwalletMain->strWalletFile, "r+");

    CKey key;
    if(!pwalletMain->GetKey(keyID, key))
        throw JSONRPCError(RPC_WALLET_ERROR, "Private key not available");

    serial_n.nVersion = CTransaction::CYCLE_TX_VERSION;

    CScript scriptPubKeyOrig;
    scriptPubKeyOrig.SetBitcoinAddress(vchPubKey.Raw());
    CScript scriptPubKey;
    vchType vchPath = vchFromString(locatorStr);
    vchType vchValue = vchFromString(indexStr);

    scriptPubKey << OP_BASE_SET << vchPath << vchValue << OP_2DROP << OP_DROP;
    scriptPubKey += scriptPubKeyOrig;

    ENTER_CRITICAL_SECTION(cs_main)
    {
        EnsureWalletIsUnlocked();

        string strError = pwalletMain->SendMoney__(scriptPubKey, CTRL__, serial_n, false);

        if(strError != "")
        {
            LEAVE_CRITICAL_SECTION(cs_main)
            throw JSONRPCError(RPC_WALLET_ERROR, strError);
        }
        mapLocator[vchPath] = serial_n.GetHash();
    }
    LEAVE_CRITICAL_SECTION(cs_main)

    return true;
}

bool sectionVertex(const string& path, string& reference)
{
    bool found=false;
    LocatorNodeDB ln1Db("r");

    Dbc* cursorp;
    try
    {
        cursorp = ln1Db.GetCursor();

        Dbt key, data;
        int ret;

        while ((ret = cursorp->get(&key, &data, DB_NEXT)) == 0)
        {
            CDataStream ssKey(SER_DISK, CLIENT_VERSION);
            ssKey.write((char*)key.get_data(), key.get_size());

            string k1;
            ssKey >> k1;
            if(k1 == "alias_")
            {
                Object o;
                vchType k2;
                ssKey >> k2;
                string a = stringFromVch(k2);
                if(a == path)
                {
                    vector<PathIndex> vtxPos;
                    CDataStream ssValue((char*)data.get_data(), (char*)data.get_data() + data.get_size(), SER_DISK, CLIENT_VERSION);
                    ssValue >> vtxPos;

                    PathIndex i = vtxPos.back();
                    string i_address = i.vAddress;
                    reference = stringFromVch(i.vValue);
                    found=true;

                }
            }
        }
    }
    catch(DbException &e)
    {
        //ln1Db.err(e.get_errno(), "Error!");
    }
    catch(std::exception &e)
    {
        //ln1Db.errx("Error! %s", e.what());
    }

    if (cursorp != NULL)
        cursorp->close();

    return found;
}

Value decryptPath_cycle(const Array& params, bool fHelp)
{
    if(fHelp || params.size() != 3)
        throw runtime_error(
            "registerPathGenerate <alias> <t> <i>"
            + HelpRequiringPassphrase());

    string locatorStr = params[0].get_str();
    string tStr = params[1].get_str();
    string iStr = params[2].get_str();

    locatorStr = stripSpacesAndQuotes(locatorStr);

    if(isOnlyWhiteSpace(locatorStr))
    {
        string err = "Attempt to register alias consisting only of white space";

        throw JSONRPCError(RPC_WALLET_ERROR, err);
    }
    else if(locatorStr.size() > 255)
    {
        string err = "Attempt to register alias more than 255 chars";

        throw JSONRPCError(RPC_WALLET_ERROR, err);
    }
    __wx__Tx vertex;
    vertex_serial_n_cycle(locatorStr, tStr + ":" + iStr, vertex);
    vector<Value> res;
    res.push_back(vertex.GetHash().GetHex());
    return res;
}
bool section_vertex_serial_n(const string& origin, const string& data, __wx__Tx& serial_n)
{
    string locatorStr = "vertex_" + origin;
    string indexStr = data;

    if(isOnlyWhiteSpace(locatorStr))
    {
        string err = "Attempt to register alias consisting only of white space";

        throw JSONRPCError(RPC_WALLET_ERROR, err);
    }
    else if(locatorStr.size() > 255)
    {
        string err = "Attempt to register alias more than 255 chars";

        throw JSONRPCError(RPC_WALLET_ERROR, err);
    }

    uint256 wtxInHash__;

    CPubKey vchPubKey;
    CReserveKey reservekey(pwalletMain);
    if(!reservekey.GetReservedKey(vchPubKey))
    {
        return false;
    }

    reservekey.KeepKey();

    cba keyAddress(vchPubKey.GetID());
    CKeyID keyID;
    keyAddress.GetKeyID(keyID);
    pwalletMain->SetAddressBookName(keyID, "");

    __wx__DB walletdb(pwalletMain->strWalletFile, "r+");

    CKey key;
    if(!pwalletMain->GetKey(keyID, key))
        throw JSONRPCError(RPC_WALLET_ERROR, "Private key not available");

    serial_n.nVersion = CTransaction::DION_TX_VERSION;

    CScript scriptPubKeyOrig;
    scriptPubKeyOrig.SetBitcoinAddress(vchPubKey.Raw());
    CScript scriptPubKey;
    vchType vchPath = vchFromString(locatorStr);
    vchType vchValue = vchFromString(indexStr);

    scriptPubKey << OP_BASE_SET << vchPath << vchValue << OP_2DROP << OP_DROP;
    scriptPubKey += scriptPubKeyOrig;

    vector< pair<CScript, int64_t> > vecSend;
    vecSend.push_back(make_pair(scriptPubKey, CTRL__));

    return true;
}
void sectionTest(CTxMemPool& testMemPool)
{
    for (map<uint256, CTransaction>::iterator mi = mempool.mapTx.begin(); mi != mempool.mapTx.end(); ++mi)
    {
        cba cAddr_;
        CTransaction& tx = (*mi).second;
        if(tx.nVersion == CTransaction::CYCLE_TX_VERSION)
        {
            string origin;
            for(int i = 0; i < tx.vout.size(); i++)
            {
                const CTxOut& out = tx.vout[i];
                std::vector<vchType> vvchArgs;

                int prevOp;
                if(aliasScript(out.scriptPubKey, prevOp, vvchArgs))
                {
                    origin = stringFromVch(vvchArgs[1]);
                    cAddr_ = out.scriptPubKey.GetBitcoinAddress();
                }
            }
            std::vector<string> contract_execution_data;
            boost::char_separator<char> tok(":");
            boost::tokenizer<boost::char_separator<char>> tokens(origin,tok);
            BOOST_FOREACH(const string& s,tokens)
            {
                contract_execution_data.push_back(s);
            }
            string target_contract = contract_execution_data[0];
            string contract_input  = contract_execution_data[1];
            string contractCode;

            bool f = getVertex__(target_contract,contractCode);
            if(f != true)
                continue;

            CKeyID keyID;
            cAddr_.GetKeyID(keyID);
            dev::Address target_addr(keyID.GetHex().c_str());

            dev::SecureTrieDB<dev::Address, dev::OverlayDB> state(overlayDB_);
            state.init();
            string account_str = state.at(target_addr);
            dev::RLP rlp_state(account_str,0);
            auto const targetAccStorageRoot = rlp_state[2].toHash<dev::h256>();
            auto const nonce = rlp_state[0].toInt<dev::u256>();
            auto const balance = rlp_state[1].toInt<dev::u256>();
            auto const codeHash = rlp_state[3].toHash<dev::h256>();
            dev::eth::Account retrievedAcc(nonce,balance,targetAccStorageRoot,codeHash,0,dev::eth::Account::Unchanged);
            string code_hex_str = contractCode;
            uint256 r;
            string val;
            dvmc::TransitionalNode account_recon;
            {
                map<dev::h256, pair<dev::bytes, dev::bytes>> ret_;
                ret_.clear();
                {
                    {
                        dev::SecureTrieDB<dev::h256, dev::OverlayDB> memdb(const_cast<dev::OverlayDB*>(overlayDB_), targetAccStorageRoot);

                        for (auto it = memdb.hashedBegin(); it != memdb.hashedEnd(); ++it)
                        {
                            dev::h256 const hashedKey((*it).first);
                            auto const key = it.key();
                            dev::bytes const value = dev::RLP((*it).second).toBytes();
                            ret_[hashedKey] = make_pair(key, value);
                        }
                    }
                }
                std::unordered_map<dvmc::bytes32, dvmc::storage_value>& storage_recon = account_recon.storage;
                for(auto i_ : ret_)
                {
                    dvmc::bytes32 reconKey;
                    dev::bytes key = i_.second.first;
                    for(int idx=0; idx<32; idx++)
                        reconKey.bytes[idx] = key[idx];
                    dvmc::storage_value sv;
                    for(int idx=0; idx<32; idx++)
                        sv.value.bytes[idx] = i_.second.second[idx];

                    storage_recon[reconKey] = sv;
                }
            }
            {
                testGen(account_recon,code_hex_str);

                dvmc::VertexNode vTrans;
                dvmc_address create_address;
                uint160 h160;
                AddressToHash160(cAddr_.ToString(),h160);
                memcpy(create_address.bytes,h160.pn,20);
                vTrans.accounts[create_address] = account_recon;
                const auto input = dvmc::from_hex(contract_input);
                dvmc_message msg{};
                msg.recipient = create_address;
                msg.track = std::numeric_limits<int64_t>::max();
                msg.input_data = input.data();
                msg.input_size = input.size();
                dvmc_revision rev = DVMC_LATEST_STABLE_REVISION;
                dvmc::VM vm = dvmc::VM{dvmc_create_dvmone()};
                const auto result = vm.retrieve_desc_vx(vTrans, rev, msg, account_recon.code.data(), account_recon.code.size());
                dvmc::TransitionalNode updatedAcc = vTrans.accounts[create_address];

                dev::SecureTrieDB<dev::Address, dev::OverlayDB> state(overlayDB_);
                state.init();
                {
                    dev::RLPStream s(4);

                    {
                        dev::SecureTrieDB<dev::h256, dev::StateCacheDB> storageDB(state.db(), retrievedAcc.baseRoot());
                        for(auto pair : updatedAcc.storage)
                        {
                            auto storage_key = pair.first.bytes;
                            dev::bytes key;
                            for(int i=0; i<32; i++)
                                key.push_back(storage_key[i]);

                            dev::h256 key256(key);

                            auto storage_bytes = pair.second.value;
                            dev::bytes val;
                            for(int i=0; i<32; i++)
                                val.push_back(storage_bytes.bytes[i]);
                            storageDB.insert(key256, dev::rlp(val));
                        }
                        s << storageDB.root();
                    }

                    s << retrievedAcc.codeHash();
                    state.insert(target_addr, &s.out());
                    overlayDB_->commit();
                }
            }
        }
    }

}

std::string code_hex_str = "";

string contract_transfer_no_check_no__transfer = "";
string code_add_require_no_trans = "";

string erc20__transfer_req1_commented_out = "";

string erc20__transfer_req12_commented_out = "";

string erc20__transfer_req123_commented_out = "";

string code_hex_trace = "0x60806040526012600260006101000a81548160ff021916908360ff1602179055503480156200002d57600080fd5b5060405162001e7538038062001e75833981810160405260608110156200005357600080fd5b8101908080519060200190929190805160405193929190846401000000008211156200007e57600080fd5b838201915060208201858111156200009557600080fd5b8251866001820283011164010000000082111715620000b357600080fd5b8083526020830192505050908051906020019080838360005b83811015620000e9578082015181840152602081019050620000cc565b50505050905090810190601f168015620001175780820380516001836020036101000a031916815260200191505b50604052602001805160405193929190846401000000008211156200013b57600080fd5b838201915060208201858111156200015257600080fd5b82518660018202830111640100000000821117156200017057600080fd5b8083526020830192505050908051906020019080838360005b83811015620001a657808201518184015260208101905062000189565b50505050905090810190601f168015620001d45780820380516001836020036101000a031916815260200191505b50604052505050600260009054906101000a900460ff1660ff16600a0a8302600381905550600354600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508160009080519060200190620002579291906200027a565b508060019080519060200190620002709291906200027a565b5050505062000329565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f10620002bd57805160ff1916838001178555620002ee565b82800160010185558215620002ee579182015b82811115620002ed578251825591602001919060010190620002d0565b5b509050620002fd919062000301565b5090565b6200032691905b808211156200032257600081600090555060010162000308565b5090565b90565b611b3c80620003396000396000f3fe608060405234801561001057600080fd5b50600436106100f55760003560e01c80636eef7a051161009757806395d89b411161006657806395d89b41146105fa578063a9059cbb1461067d578063cae9ca51146106e3578063dd62ed3e146107e0576100f5565b80636eef7a05146103ae57806370a082311461045557806374546363146104ad57806379cc679014610594576100f5565b806323b872dd116100d357806323b872dd14610201578063313ce5671461028757806342966c68146102ab5780635e57966d146102f1576100f5565b806306fdde03146100fa578063095ea7b31461017d57806318160ddd146101e3575b600080fd5b610102610858565b6040518080602001828103825283818151815260200191508051906020019080838360005b83811015610142578082015181840152602081019050610127565b50505050905090810190601f16801561016f5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6101c96004803603604081101561019357600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001909291905050506108f6565b604051808215151515815260200191505060405180910390f35b6101eb6109e8565b6040518082815260200191505060405180910390f35b61026d6004803603606081101561021757600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001909291905050506109ee565b604051808215151515815260200191505060405180910390f35b61028f610b19565b604051808260ff1660ff16815260200191505060405180910390f35b6102d7600480360360208110156102c157600080fd5b8101908080359060200190929190505050610b2c565b604051808215151515815260200191505060405180910390f35b6103336004803603602081101561030757600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610c2e565b6040518080602001828103825283818151815260200191508051906020019080838360005b83811015610373578082015181840152602081019050610358565b50505050905090810190601f1680156103a05780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6103da600480360360208110156103c457600080fd5b8101908080359060200190929190505050610eaf565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561041a5780820151818401526020810190506103ff565b50505050905090810190601f1680156104475780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6104976004803603602081101561046b57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611110565b6040518082815260200191505060405180910390f35b610519600480360360608110156104c357600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050611128565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561055957808201518184015260208101905061053e565b50505050905090810190601f1680156105865780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6105e0600480360360408110156105aa57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050611389565b604051808215151515815260200191505060405180910390f35b61060261159f565b6040518080602001828103825283818151815260200191508051906020019080838360005b83811015610642578082015181840152602081019050610627565b50505050905090810190601f16801561066f5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6106c96004803603604081101561069357600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff1690602001909291908035906020019092919050505061163d565b604051808215151515815260200191505060405180910390f35b6107c6600480360360608110156106f957600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001909291908035906020019064010000000081111561074057600080fd5b82018360208201111561075257600080fd5b8035906020019184600183028401116401000000008311171561077457600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f820116905080830192505050505050509192919290505050611654565b604051808215151515815260200191505060405180910390f35b610842600480360360408110156107f657600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff1690602001909291905050506117bc565b6040518082815260200191505060405180910390f35b60008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156108ee5780601f106108c3576101008083540402835291602001916108ee565b820191906000526020600020905b8154815290600101906020018083116108d157829003601f168201915b505050505081565b600081600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040518082815260200191505060405180910390a36001905092915050565b60035481565b6000600560008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054821115610a7957600080fd5b81600560008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282540392505081905550610b0e8484846117e1565b600190509392505050565b600260009054906101000a900460ff1681565b600081600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015610b7a57600080fd5b81600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282540392505081905550816003600082825403925050819055503373ffffffffffffffffffffffffffffffffffffffff167fcc16f5dbb4873280815c1ee09dbd06736cffcc184412cf7a71a0fdb75d397ca5836040518082815260200191505060405180910390a260019050919050565b606060008273ffffffffffffffffffffffffffffffffffffffff1660001b905060606040518060400160405280601081526020017f30313233343536373839616263646566000000000000000000000000000000008152509050606060336040519080825280601f01601f191660200182016040528015610cbe5781602001600182028038833980820191505090505b5090507f300000000000000000000000000000000000000000000000000000000000000081600081518110610cef57fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053507f780000000000000000000000000000000000000000000000000000000000000081600181518110610d4c57fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535060008090505b6014811015610ea35782600485600c840160208110610d9c57fe5b1a60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916901c60f81c60ff1681518110610dd457fe5b602001015160f81c60f81b826002830260020181518110610df157fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535082600f60f81b85600c840160208110610e3557fe5b1a60f81b1660f81c60ff1681518110610e4a57fe5b602001015160f81c60f81b826002830260030181518110610e6757fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053508080600101915050610d81565b50809350505050919050565b6060806040518060400160405280601081526020017f30313233343536373839616263646566000000000000000000000000000000008152509050606060336040519080825280601f01601f191660200182016040528015610f205781602001600182028038833980820191505090505b5090507f300000000000000000000000000000000000000000000000000000000000000081600081518110610f5157fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053507f780000000000000000000000000000000000000000000000000000000000000081600181518110610fae57fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535060008090505b60148110156111055782600486600c840160208110610ffe57fe5b1a60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916901c60f81c60ff168151811061103657fe5b602001015160f81c60f81b82600283026002018151811061105357fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535082600f60f81b86600c84016020811061109757fe5b1a60f81b1660f81c60ff16815181106110ac57fe5b602001015160f81c60f81b8260028302600301815181106110c957fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053508080600101915050610fe3565b508092505050919050565b60046020528060005260406000206000915090505481565b606060008260001b905061113b85610c2e565b61114485610c2e565b61114d83610eaf565b6040516020018082805190602001908083835b602083106111835780518252602082019150602081019050602083039250611160565b6001836020036101000a0380198251168184511680821785525050505050509050019150506040516020818303038152906040526040516020018083805190602001908083835b602083106111ed57805182526020820191506020810190506020830392506111ca565b6001836020036101000a038019825116818451168082178552505050505050905001807f2c2000000000000000000000000000000000000000000000000000000000000081525060020182805190602001908083835b602083106112665780518252602082019150602081019050602083039250611243565b6001836020036101000a038019825116818451168082178552505050505050905001925050506040516020818303038152906040526040516020018083805190602001908083835b602083106112d157805182526020820191506020810190506020830392506112ae565b6001836020036101000a038019825116818451168082178552505050505050905001807f2c2000000000000000000000000000000000000000000000000000000000000081525060020182805190602001908083835b6020831061134a5780518252602082019150602081019050602083039250611327565b6001836020036101000a038019825116818451168082178552505050505050905001925050506040516020818303038152906040529150509392505050565b600081600460008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410156113d757600080fd5b600560008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205482111561146057600080fd5b81600460008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254039250508190555081600560008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282540392505081905550816003600082825403925050819055508273ffffffffffffffffffffffffffffffffffffffff167fcc16f5dbb4873280815c1ee09dbd06736cffcc184412cf7a71a0fdb75d397ca5836040518082815260200191505060405180910390a26001905092915050565b60018054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156116355780601f1061160a57610100808354040283529160200191611635565b820191906000526020600020905b81548152906001019060200180831161161857829003601f168201915b505050505081565b600061164a3384846117e1565b6001905092915050565b60008084905061166485856108f6565b156117b3578073ffffffffffffffffffffffffffffffffffffffff16638f4ffcb1338630876040518563ffffffff1660e01b8152600401808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018481526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200180602001828103825283818151815260200191508051906020019080838360005b83811015611742578082015181840152602081019050611727565b50505050905090810190601f16801561176f5780820380516001836020036101000a031916815260200191505b5095505050505050600060405180830381600087803b15801561179157600080fd5b505af11580156117a5573d6000803e3d6000fd5b5050505060019150506117b5565b505b9392505050565b6005602052816000526040600020602052806000526040600020600091509150505481565b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff16141561181b57600080fd5b80600460008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054101561186757600080fd5b600460008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205481600460008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020540110156118f457600080fd5b6000600460008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205401905081600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254039250508190555081600460008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a380600460008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054600460008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020540114611b0157fe5b5050505056fea265627a7a7231582090a370df1504357cad55837085e9ed659bf0984b9ee6449a3f98e528bd51085664736f6c6343000511003200000000000000000000000000000000000000000000000000000000000003e8000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000001610000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000016200000000000000000000000000000000000000000000000000000000000000";

string code_hex_09112022_trace = "0x60806040526012600260006101000a81548160ff021916908360ff1602179055503480156200002d57600080fd5b5060405162001efe38038062001efe833981810160405260608110156200005357600080fd5b8101908080519060200190929190805160405193929190846401000000008211156200007e57600080fd5b838201915060208201858111156200009557600080fd5b8251866001820283011164010000000082111715620000b357600080fd5b8083526020830192505050908051906020019080838360005b83811015620000e9578082015181840152602081019050620000cc565b50505050905090810190601f168015620001175780820380516001836020036101000a031916815260200191505b50604052602001805160405193929190846401000000008211156200013b57600080fd5b838201915060208201858111156200015257600080fd5b82518660018202830111640100000000821117156200017057600080fd5b8083526020830192505050908051906020019080838360005b83811015620001a657808201518184015260208101905062000189565b50505050905090810190601f168015620001d45780820380516001836020036101000a031916815260200191505b50604052505050600260009054906101000a900460ff1660ff16600a0a8302600381905550600354600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508160009080519060200190620002579291906200027a565b508060019080519060200190620002709291906200027a565b5050505062000329565b828054600181600116156101000203166002900490600052602060002090601f016020900481019282601f10620002bd57805160ff1916838001178555620002ee565b82800160010185558215620002ee579182015b82811115620002ed578251825591602001919060010190620002d0565b5b509050620002fd919062000301565b5090565b6200032691905b808211156200032257600081600090555060010162000308565b5090565b90565b611bc580620003396000396000f3fe608060405234801561001057600080fd5b50600436106100f55760003560e01c80636eef7a051161009757806395d89b411161006657806395d89b41146105fa578063a9059cbb1461067d578063cae9ca51146106e3578063dd62ed3e146107e0576100f5565b80636eef7a05146103ae57806370a082311461045557806374546363146104ad57806379cc679014610594576100f5565b806323b872dd116100d357806323b872dd14610201578063313ce5671461028757806342966c68146102ab5780635e57966d146102f1576100f5565b806306fdde03146100fa578063095ea7b31461017d57806318160ddd146101e3575b600080fd5b610102610858565b6040518080602001828103825283818151815260200191508051906020019080838360005b83811015610142578082015181840152602081019050610127565b50505050905090810190601f16801561016f5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6101c96004803603604081101561019357600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001909291905050506108f6565b604051808215151515815260200191505060405180910390f35b6101eb6109e8565b6040518082815260200191505060405180910390f35b61026d6004803603606081101561021757600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001909291905050506109ee565b604051808215151515815260200191505060405180910390f35b61028f610b19565b604051808260ff1660ff16815260200191505060405180910390f35b6102d7600480360360208110156102c157600080fd5b8101908080359060200190929190505050610b2c565b604051808215151515815260200191505060405180910390f35b6103336004803603602081101561030757600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050610c2e565b6040518080602001828103825283818151815260200191508051906020019080838360005b83811015610373578082015181840152602081019050610358565b50505050905090810190601f1680156103a05780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6103da600480360360208110156103c457600080fd5b8101908080359060200190929190505050610eaf565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561041a5780820151818401526020810190506103ff565b50505050905090810190601f1680156104475780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6104976004803603602081101561046b57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611110565b6040518082815260200191505060405180910390f35b610519600480360360608110156104c357600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050611128565b6040518080602001828103825283818151815260200191508051906020019080838360005b8381101561055957808201518184015260208101905061053e565b50505050905090810190601f1680156105865780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6105e0600480360360408110156105aa57600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff16906020019092919080359060200190929190505050611412565b604051808215151515815260200191505060405180910390f35b610602611628565b6040518080602001828103825283818151815260200191508051906020019080838360005b83811015610642578082015181840152602081019050610627565b50505050905090810190601f16801561066f5780820380516001836020036101000a031916815260200191505b509250505060405180910390f35b6106c96004803603604081101561069357600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001909291905050506116c6565b604051808215151515815260200191505060405180910390f35b6107c6600480360360608110156106f957600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803590602001909291908035906020019064010000000081111561074057600080fd5b82018360208201111561075257600080fd5b8035906020019184600183028401116401000000008311171561077457600080fd5b91908080601f016020809104026020016040519081016040528093929190818152602001838380828437600081840152601f19601f8201169050808301925050505050505091929192905050506116dd565b604051808215151515815260200191505060405180910390f35b610842600480360360408110156107f657600080fd5b81019080803573ffffffffffffffffffffffffffffffffffffffff169060200190929190803573ffffffffffffffffffffffffffffffffffffffff169060200190929190505050611845565b6040518082815260200191505060405180910390f35b60008054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156108ee5780601f106108c3576101008083540402835291602001916108ee565b820191906000526020600020905b8154815290600101906020018083116108d157829003601f168201915b505050505081565b600081600560003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020819055508273ffffffffffffffffffffffffffffffffffffffff163373ffffffffffffffffffffffffffffffffffffffff167f8c5be1e5ebec7d5bd14f71427d1e84f3dd0314c0f7b2291e5b200ac8c7c3b925846040518082815260200191505060405180910390a36001905092915050565b60035481565b6000600560008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054821115610a7957600080fd5b81600560008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282540392505081905550610b0e84848461186a565b600190509392505050565b600260009054906101000a900460ff1681565b600081600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020541015610b7a57600080fd5b81600460003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282540392505081905550816003600082825403925050819055503373ffffffffffffffffffffffffffffffffffffffff167fcc16f5dbb4873280815c1ee09dbd06736cffcc184412cf7a71a0fdb75d397ca5836040518082815260200191505060405180910390a260019050919050565b606060008273ffffffffffffffffffffffffffffffffffffffff1660001b905060606040518060400160405280601081526020017f30313233343536373839616263646566000000000000000000000000000000008152509050606060336040519080825280601f01601f191660200182016040528015610cbe5781602001600182028038833980820191505090505b5090507f300000000000000000000000000000000000000000000000000000000000000081600081518110610cef57fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053507f780000000000000000000000000000000000000000000000000000000000000081600181518110610d4c57fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535060008090505b6014811015610ea35782600485600c840160208110610d9c57fe5b1a60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916901c60f81c60ff1681518110610dd457fe5b602001015160f81c60f81b826002830260020181518110610df157fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535082600f60f81b85600c840160208110610e3557fe5b1a60f81b1660f81c60ff1681518110610e4a57fe5b602001015160f81c60f81b826002830260030181518110610e6757fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053508080600101915050610d81565b50809350505050919050565b6060806040518060400160405280601081526020017f30313233343536373839616263646566000000000000000000000000000000008152509050606060336040519080825280601f01601f191660200182016040528015610f205781602001600182028038833980820191505090505b5090507f300000000000000000000000000000000000000000000000000000000000000081600081518110610f5157fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053507f780000000000000000000000000000000000000000000000000000000000000081600181518110610fae57fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535060008090505b60148110156111055782600486600c840160208110610ffe57fe5b1a60f81b7effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916901c60f81c60ff168151811061103657fe5b602001015160f81c60f81b82600283026002018151811061105357fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a90535082600f60f81b86600c84016020811061109757fe5b1a60f81b1660f81c60ff16815181106110ac57fe5b602001015160f81c60f81b8260028302600301815181106110c957fe5b60200101907effffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff1916908160001a9053508080600101915050610fe3565b508092505050919050565b60046020528060005260406000206000915090505481565b606060008260001b9050606061113d33610c2e565b905061114886610c2e565b61115186610c2e565b61115a84610eaf565b6040516020018082805190602001908083835b60208310611190578051825260208201915060208101905060208303925061116d565b6001836020036101000a038019825116818451168082178552505050505050905001915050604051602081830303815290604052836040516020018084805190602001908083835b602083106111fb57805182526020820191506020810190506020830392506111d8565b6001836020036101000a038019825116818451168082178552505050505050905001807f2c2000000000000000000000000000000000000000000000000000000000000081525060020183805190602001908083835b602083106112745780518252602082019150602081019050602083039250611251565b6001836020036101000a038019825116818451168082178552505050505050905001807f2c206d73672e73656e6465722000000000000000000000000000000000000000815250600d0182805190602001908083835b602083106112ed57805182526020820191506020810190506020830392506112ca565b6001836020036101000a03801982511681845116808217855250505050505090500193505050506040516020818303038152906040526040516020018083805190602001908083835b602083106113595780518252602082019150602081019050602083039250611336565b6001836020036101000a038019825116818451168082178552505050505050905001807f2c2000000000000000000000000000000000000000000000000000000000000081525060020182805190602001908083835b602083106113d257805182526020820191506020810190506020830392506113af565b6001836020036101000a03801982511681845116808217855250505050505090500192505050604051602081830303815290604052925050509392505050565b600081600460008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054101561146057600080fd5b600560008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020548211156114e957600080fd5b81600460008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254039250508190555081600560008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060003373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002060008282540392505081905550816003600082825403925050819055508273ffffffffffffffffffffffffffffffffffffffff167fcc16f5dbb4873280815c1ee09dbd06736cffcc184412cf7a71a0fdb75d397ca5836040518082815260200191505060405180910390a26001905092915050565b60018054600181600116156101000203166002900480601f0160208091040260200160405190810160405280929190818152602001828054600181600116156101000203166002900480156116be5780601f10611693576101008083540402835291602001916116be565b820191906000526020600020905b8154815290600101906020018083116116a157829003601f168201915b505050505081565b60006116d333848461186a565b6001905092915050565b6000808490506116ed85856108f6565b1561183c578073ffffffffffffffffffffffffffffffffffffffff16638f4ffcb1338630876040518563ffffffff1660e01b8152600401808573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020018481526020018373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200180602001828103825283818151815260200191508051906020019080838360005b838110156117cb5780820151818401526020810190506117b0565b50505050905090810190601f1680156117f85780820380516001836020036101000a031916815260200191505b5095505050505050600060405180830381600087803b15801561181a57600080fd5b505af115801561182e573d6000803e3d6000fd5b50505050600191505061183e565b505b9392505050565b6005602052816000526040600020602052806000526040600020600091509150505481565b600073ffffffffffffffffffffffffffffffffffffffff168273ffffffffffffffffffffffffffffffffffffffff1614156118a457600080fd5b80600460008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205410156118f057600080fd5b600460008373ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205481600460008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205401101561197d57600080fd5b6000600460008473ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000205401905081600460008673ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff1681526020019081526020016000206000828254039250508190555081600460008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020600082825401925050819055508273ffffffffffffffffffffffffffffffffffffffff168473ffffffffffffffffffffffffffffffffffffffff167fddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef846040518082815260200191505060405180910390a380600460008573ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff16815260200190815260200160002054600460008773ffffffffffffffffffffffffffffffffffffffff1673ffffffffffffffffffffffffffffffffffffffff168152602001908152602001600020540114611b8a57fe5b5050505056fea265627a7a72315820af7e8bbbb6d6a9741aba102f7f3596e217365cf91a782527fe8726f22d31901964736f6c6343000511003200000000000000000000000000000000000000000000000000000000000003e8000000000000000000000000000000000000000000000000000000000000006000000000000000000000000000000000000000000000000000000000000000a00000000000000000000000000000000000000000000000000000000000000001610000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000016200000000000000000000000000000000000000000000000000000000000000";


//erc20 with balanceOf adjust in approve routine
//
string code_with_balance_adjust_in_approve_str = "";


string erc20_15112022_endowed_with_5_eth = "";


string erc20_17112022_send_fixed_amount_1 = "";

string erc20_19112022_withdraw_with_parameter = "";

string erc20_22112022_withdraw_with_parameter_subtract_15 = "";

Value integratedTest1(const Array& params, bool fHelp)
{
    if(fHelp || params.size() > 0)
        throw runtime_error(
            " no args"
            + HelpRequiringPassphrase());

    vector<Value> res;
    constexpr auto create_address         = 0xc9ea7ed000000000000000000000000000000001_address;
    constexpr auto test_sender_address    = 0x5b38da6a701c568545dcfcb03fcb875f56beddc4_address;
    constexpr auto test_recipient_address = 0x5b38da6a701c568545dcfcb03fcb875f56beddc4_address;
    std::cout << " : initialised create address " << dvmc::hex(create_address.bytes) << "\n";
    std::cout << " : initialised from address " << dvmc::hex(test_sender_address.bytes) << "\n";
    std::cout << " : initialised to address " << dvmc::hex(test_recipient_address.bytes) << "\n";
    const auto code = dvmc::from_hex(erc20_22112022_withdraw_with_parameter_subtract_15);

    dvmc::VertexNode host;
    dvmc::TransitionalNode created_account;
    dvmc::TransitionalNode sender_account;
    sender_account.set_balance(3141);

    dvmc_message msg{};
    msg.track = std::numeric_limits<int64_t>::max();

    dvmc::bytes_view exec_code = code;
    {
        dvmc_message create_msg{};
        create_msg.kind = DVMC_CREATE;
        create_msg.recipient = create_address;
        create_msg.track = std::numeric_limits<int64_t>::max();

        dvmc_revision rev = DVMC_LATEST_STABLE_REVISION;
        dvmc::VM vm = dvmc::VM{dvmc_create_dvmone()};
        const auto create_result = vm.retrieve_desc_vx(host, rev, create_msg, code.data(), code.size());
        if (create_result.status_code != DVMC_SUCCESS)
        {
            std::cout << " : Contract creation failed: " << create_result.status_code << "\n";
            return create_result.status_code;
        }

        auto& created_account = host.accounts[create_address];
        created_account.set_balance(100000000000000);

        created_account.code = dvmc::bytes(create_result.output_data, create_result.output_size);

        msg.recipient = create_address;
        exec_code = created_account.code;
    }
    {
        std::cout << "\n";
        const auto input = dvmc::from_hex("0x18160ddd");
        msg.input_data = input.data();
        msg.input_size = input.size();

        dvmc_revision rev = DVMC_LATEST_STABLE_REVISION;
        dvmc::VM vm = dvmc::VM{dvmc_create_dvmone()};
        const auto result = vm.retrieve_desc_vx(host, rev, msg, exec_code.data(), exec_code.size());

        //if (bench)
        //    tooling::bench(host, vm, rev, msg, exec_code, result, out);

        const auto track_used = msg.track - result.track_left;
        std::cout << " : Result: totalSupply  " << result.status_code << "\nTrack used: " << track_used << "\n";

        if (result.status_code == DVMC_SUCCESS || result.status_code == DVMC_REVERT)
            std::cout << "Output:   " << dvmc::hex({result.output_data, result.output_size}) << "\n";
    }
    {
        std::cout << "\n";
        const auto input = dvmc::from_hex("0x42966c68000000000000000000000000000000000000000000000000000000000000029a");
        msg.input_data = input.data();
        msg.input_size = input.size();

        dvmc_revision rev = DVMC_LATEST_STABLE_REVISION;
        dvmc::VM vm = dvmc::VM{dvmc_create_dvmone()};
        const auto result = vm.retrieve_desc_vx(host, rev, msg, exec_code.data(), exec_code.size());

        //if (bench)
        //    tooling::bench(host, vm, rev, msg, exec_code, result, out);

        const auto track_used = msg.track - result.track_left;
        std::cout << " : Result: Burn  " << result.status_code << "\nTrack used: " << track_used << "\n";

        if (result.status_code == DVMC_SUCCESS || result.status_code == DVMC_REVERT)
            std::cout << "Output:   " << dvmc::hex({result.output_data, result.output_size}) << "\n";
    }
    {
        std::cout << "\n";
        const auto input = dvmc::from_hex("0x18160ddd");
        msg.input_data = input.data();
        msg.input_size = input.size();

        dvmc_revision rev = DVMC_LATEST_STABLE_REVISION;
        dvmc::VM vm = dvmc::VM{dvmc_create_dvmone()};
        const auto result = vm.retrieve_desc_vx(host, rev, msg, exec_code.data(), exec_code.size());

        //if (bench)
        //    tooling::bench(host, vm, rev, msg, exec_code, result, out);

        const auto track_used = msg.track - result.track_left;
        std::cout << " : Result: totalSupply  " << result.status_code << "\nTrack used: " << track_used << "\n";

        if (result.status_code == DVMC_SUCCESS || result.status_code == DVMC_REVERT)
            std::cout << " : Output:   " << dvmc::hex({result.output_data, result.output_size}) << "\n";
    }
    {
        const auto input = dvmc::from_hex("0x095ea7b30000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc40000000000000000000000000000000000000000000000000000000000000050");
        msg.sender = test_sender_address;
        msg.input_data = input.data();
        msg.input_size = input.size();

        dvmc_revision rev = DVMC_LATEST_STABLE_REVISION;
        dvmc::VM vm = dvmc::VM{dvmc_create_dvmone()};
        const auto result = vm.retrieve_desc_vx(host, rev, msg, exec_code.data(), exec_code.size());

        //if (bench)
        //    tooling::bench(host, vm, rev, msg, exec_code, result, out);

        const auto track_used = msg.track - result.track_left;
        std::cout << " : Result:   " << result.status_code << "\nTrack used: " << track_used << "\n";

    }
    {
        std::cout << "\n";
        const auto input = dvmc::from_hex("0xdd62ed3e0000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc40000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc4");
        msg.input_data = input.data();
        msg.input_size = input.size();

        dvmc_revision rev = DVMC_LATEST_STABLE_REVISION;
        dvmc::VM vm = dvmc::VM{dvmc_create_dvmone()};
        const auto result = vm.retrieve_desc_vx(host, rev, msg, exec_code.data(), exec_code.size());

        //if (bench)
        //    tooling::bench(host, vm, rev, msg, exec_code, result, out);

        const auto track_used = msg.track - result.track_left;
        std::cout << " : Result:   " << result.status_code << "\nTrack used: " << track_used << "\n";

    }
    {
        std::cout << "\n";
        const auto input = dvmc::from_hex("0x23b872dd0000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc40000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc40000000000000000000000000000000000000000000000000000000000000037");

        msg.track = std::numeric_limits<int64_t>::max();
        msg.input_data = input.data();
        msg.input_size = input.size();
        dvmc_revision rev = DVMC_LATEST_STABLE_REVISION;
        dvmc::VM vm = dvmc::VM{dvmc_create_dvmone()};
        const auto result = vm.retrieve_desc_vx(host, rev, msg, exec_code.data(), exec_code.size());

        //if (bench)
        //    tooling::bench(host, vm, rev, msg, exec_code, result, out);

        const auto track_used = msg.track - result.track_left;
        std::cout << " : Result: transfer_from  " << result.status_code << "\nTrack used: " << track_used << "\n";

    }
    {
        std::cout << "\n";
        const auto input = dvmc::from_hex("0xdd62ed3e0000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc40000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc4");
        msg.input_data = input.data();
        msg.input_size = input.size();

        dvmc_revision rev = DVMC_LATEST_STABLE_REVISION;
        dvmc::VM vm = dvmc::VM{dvmc_create_dvmone()};
        const auto result = vm.retrieve_desc_vx(host, rev, msg, exec_code.data(), exec_code.size());


        //if (bench)
        //    tooling::bench(host, vm, rev, msg, exec_code, result, out);

        const auto track_used = msg.track - result.track_left;
        std::cout << " : Result:   " << result.status_code << "\nTrack used: " << track_used << "\n";

        if (result.status_code == DVMC_SUCCESS || result.status_code == DVMC_REVERT)
            std::cout << " : Output: allowance  " << dvmc::hex({result.output_data, result.output_size}) << "\n";
    }
    {
        std::cout << "\n";
        const auto input =   dvmc::from_hex("0x486556ce0000000000000000000000000000000000000000000000000000000000031415");
        msg.sender = test_sender_address;
        msg.recipient = create_address;
        msg.input_data = input.data();
        msg.input_size = input.size();
        dvmc::bytes32 bytes__sender_before = host.get_balance(test_sender_address);
        dvmc::bytes32 bytes__ = host.get_balance(create_address);

        dvmc_revision rev = DVMC_LATEST_STABLE_REVISION;
        dvmc::VM vm = dvmc::VM{dvmc_create_dvmone()};
        const auto result = vm.retrieve_desc_vx(host, rev, msg, exec_code.data(), exec_code.size());

        dvmc::bytes32 bytes__sender_after = host.get_balance(test_sender_address);
        dvmc::bytes32 bytes__contract_after = host.get_balance(create_address);

        unsigned char test_bytes[] = {
            0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,
            0,0,0,0,0,0x03,0x14,0x06
        };
        uint256 test = test_bytes[0];
        unsigned int test2;

        uint256 msg_test_bytes;
        for(int i=0; i<8; i++)
        {
            unsigned int b1 = test_bytes[i*4];
            b1<<=24;
            unsigned int b2 = test_bytes[i*4+1];
            b2<<=16;
            unsigned int b3 = test_bytes[i*4+2];
            b3<<=8;
            unsigned int b4 = test_bytes[i*4+3];
            b4<<=0;
            unsigned int p_i = b1 + b2 + b3 + b4;
            msg_test_bytes.pn[7 - i] = p_i;
        }
        msg_test_bytes +=1;

        uint64_t msg_test_bytes64 = msg_test_bytes.pn[0];
        msg_test_bytes64 += (0x00000000fffffffff&msg_test_bytes.pn[1])<<32;

        const auto track_used = msg.track - result.track_left;
    }

    std::unique_ptr<dev::db::DatabaseFace> db = dev::db::DBFactory::create("/home/argon/data1/testnet/state");
    dev::SecureTrieDB<dev::Address, dev::OverlayDB> state(overlayDB_);
    state.init();
    dev::Address tmpAddr("9999999999999996789012345678901234567890");
    dev::eth::Account tmpAcc(0,0);
    {
        dev::u256 nonce = 12345678;
        dev::u256 balance = 1010101010101;
        dev::RLPStream s(4);
        s << nonce << balance;

        {
            dev::SecureTrieDB<dev::h256, dev::StateCacheDB> storageDB(state.db(), tmpAcc.baseRoot());
            auto& created_account__ = host.accounts[create_address];
            for(auto pair : created_account__.storage)
            {
                auto storage_key = pair.first.bytes;
                dev::bytes key;
                for(int i=0; i<32; i++)
                    key.push_back(storage_key[i]);

                dev::h256 key256(key);

                auto storage_bytes = pair.second.value;
                dev::bytes val;
                std::cout << "preparing insert dev::bytes val in trie, val.size " << val.size() << std::endl;
                for(int i=0; i<32; i++)
                    val.push_back(storage_bytes.bytes[i]);
                std::cout << "insert " << storageDB.root() << std::endl;
                std::cout << "preparing insert convert val toString" << std::endl;
                std::cout << "preparing insert compare toString with orig" << std::endl;
                std::cout << "preparing insert prior to insert val.size " << val.size() << std::endl;
                bool collide=true;
                for(int i=0; i<32; i++)
                {
                    if(val[i] != storage_bytes.bytes[i])
                    {
                        collide=false;
                        break;
                    }
                }
                std::cout << "preparing insert compare val with orig " << collide << std::endl;
                storageDB.insert(key256, dev::rlp(val));
            }
            s << storageDB.root();
        }

        s << tmpAcc.codeHash();
        state.insert(tmpAddr, &s.out());
        overlayDB_.commit();
    }
    auto created_acc = host.accounts[create_address];
    dvmc::TransitionalNode account_recon;
    auto& node_map = host.accounts;
    account_recon.storage = created_acc.storage;
    account_recon.code = created_acc.code;
    account_recon.balance = created_acc.balance;
    node_map[create_address] = account_recon;
    std::cout << "direct copy storage plus code plus balance to recon" << std::endl;
    {
        std::cout << "RECON QUERY ALLOWANCE" << std::endl;
        std::cout << "\n";
        const auto input = dvmc::from_hex("0xdd62ed3e0000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc40000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc4");
        msg.input_data = input.data();
        msg.input_size = input.size();

        dvmc_revision rev = DVMC_LATEST_STABLE_REVISION;
        dvmc::VM vm = dvmc::VM{dvmc_create_dvmone()};
        const auto result = vm.retrieve_desc_vx(host, rev, msg, exec_code.data(), exec_code.size());


        //if (bench)
        //    tooling::bench(host, vm, rev, msg, exec_code, result, out);

        const auto track_used = msg.track - result.track_left;
        std::cout << " : after recon Result:   " << result.status_code << "\nTrack used: " << track_used << "\n";

        if (result.status_code == DVMC_SUCCESS || result.status_code == DVMC_REVERT)
            std::cout << " : Output: after recon allowance  " << dvmc::hex({result.output_data, result.output_size}) << "\n";
    }
    std::cout << "========================================================================" << std::endl;
    {
        string account_str = state.at(tmpAddr);
        dev::RLP rlp_state(account_str,0);
        auto const nonce = rlp_state[0].toInt<dev::u256>();
        std::cout << "extracted nonce " << nonce << std::endl;
        auto const balance = rlp_state[1].toInt<dev::u256>();
        std::cout << "extracted balance " << balance << std::endl;
        auto const tmpAccstorageRoot = rlp_state[2].toHash<dev::h256>();
        std::cout << "extracted storageRoot " << tmpAccstorageRoot << std::endl;
        auto const codeHash = rlp_state[3].toHash<dev::h256>();
        std::cout << "integratedTest 1 extracted codeHash " << codeHash << std::endl;

        dev::eth::Account retrievedAcc(nonce,balance,tmpAccstorageRoot,codeHash,0,dev::eth::Account::Unchanged);
        std::cout << "integratedTest 1 pull from trie storage 1" << std::endl;
        {
            map<dev::h256, pair<dev::u256, dev::u256>> ret;
            map<dev::h256, pair<dev::bytes, dev::bytes>> ret_;
            ret_.clear();
            std::cout << "created ret_.size " << ret_.size() << std::endl;
            for(auto p : ret_)
                std::cout << "after creation ret_ entry" << std::endl;

            {
                {
                    dev::SecureTrieDB<dev::h256, dev::OverlayDB> memdb(const_cast<dev::OverlayDB*>(overlayDB_), tmpAccstorageRoot);

                    for (auto it = memdb.hashedBegin(); it != memdb.hashedEnd(); ++it)
                    {
                        dev::h256 const hashedKey((*it).first);
                        auto const key = it.key();
                        dev::bytes const value = dev::RLP((*it).second).toBytes();
                        std::cout << "integratedTest 1 set ret_ hash map key value" << std::endl;
                        ret_[hashedKey] = make_pair(key, value);
                    }
                }
                for(auto p : ret_)
                    std::cout << "after setting ret_ entry" << std::endl;
                auto created_account__ = host.accounts[create_address];
                std::cout << "created_account__.storage.size " << created_account__.storage.size() << std::endl;
                for(auto pair : created_account__.storage)
                {
                    auto storage_key = pair.first.bytes;
                    for(auto i_ret_ : ret_)
                    {
                        dev::bytes key = i_ret_.second.first;
                        bool collide = true;
                        for(int index=0; index<32; index++)
                        {
                            if(storage_key[index] != key[index])
                            {
                                collide=false;
                                break;
                            }
                        }
                        if(collide == true)
                            std::cout << "found collideing key bytes" << std::endl;
                    }
                }
                std::cout << "integratedTest 1 map ret_.size() " << ret_.size() << std::endl;
                std::cout << "prior to val scan entries ret_.size " << ret_.size() << std::endl;
                for(auto p : ret_)
                    std::cout << "prior to val scan ret_ entry" << std::endl;
                std::cout << "================== scan values ================== " << std::endl;
                std::cout << "ret_.size " << ret_.size() << std::endl;
                std::cout << "prior to val scan created_account__.storage.size " << created_account__.storage.size() << std::endl;
                for(auto pair : created_account__.storage)
                {
                    auto storage_value = pair.second.value;
                    for(auto i_ret_ : ret_)
                    {
                        dev::bytes val = i_ret_.second.second;
                        bool collide = true;
                        for(int index=0; index<32; index++)
                        {
                            if(storage_value.bytes[index] != val[index])
                            {
                                collide=false;
                                break;
                            }
                        }
                        if(collide == true)
                            std::cout << "found collideing value bytes" << std::endl;
                    }
                }
                std::cout << "================== scan values end ================== " << std::endl;
            }
            dvmc::TransitionalNode account_recon;
            std::unordered_map<dvmc::bytes32, dvmc::storage_value>& storage_recon = account_recon.storage;
            for(auto i_ : ret_)
            {
                dvmc::bytes32 reconKey;
                dev::bytes key = i_.second.first;
                for(int idx=0; idx<32; idx++)
                    reconKey.bytes[idx] = key[idx];
                dvmc::storage_value sv;
                for(int idx=0; idx<32; idx++)
                    sv.value.bytes[idx] = i_.second.second[idx];

                storage_recon[reconKey] = sv;
            }

            auto& created_account___ = host.accounts[create_address];
            {
                for(auto pair : created_account___.storage)
                {
                    for(auto pair_r : account_recon.storage)
                    {
                        bool collide=true;
                        for(int idx=0; idx<32; idx++)
                        {
                            if(pair_r.first.bytes[idx] != pair.first.bytes[idx])
                            {
                                collide=false;
                                break;
                            }
                        }
                        if(collide) std::cout << "key collide" << std::endl;
                    }
                }
            }
            {
                for(auto pair : created_account___.storage)
                {
                    dvmc::storage_value sv = account_recon.storage[pair.first];
                    if(sv.value == pair.second.value)
                        std::cout << "payload collide" << std::endl;
                    else
                        std::cout << "payload does not collide" << std::endl;

                }
            }
            account_recon.nonce = created_account___.nonce;
            account_recon.balance = created_account___.balance;
            account_recon.code = created_account___.code;
            created_account___ = account_recon;
            {
                std::cout << "RECON TEST" << std::endl;
                std::cout << "\n";
                const auto input = dvmc::from_hex("0xdd62ed3e0000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc40000000000000000000000005b38da6a701c568545dcfcb03fcb875f56beddc4");
                msg.input_data = input.data();
                msg.input_size = input.size();

                dvmc_revision rev = DVMC_LATEST_STABLE_REVISION;
                dvmc::VM vm = dvmc::VM{dvmc_create_dvmone()};
                const auto result = vm.retrieve_desc_vx(host, rev, msg, exec_code.data(), exec_code.size());


                //if (bench)
                //    tooling::bench(host, vm, rev, msg, exec_code, result, out);

                const auto track_used = msg.track - result.track_left;
                std::cout << " : after recon Result:   " << result.status_code << "\nTrack used: " << track_used << "\n";

                if (result.status_code == DVMC_SUCCESS || result.status_code == DVMC_REVERT)
                    std::cout << " : Output: after recon allowance  " << dvmc::hex({result.output_data, result.output_size}) << "\n";
            }
        }
    }


    return res;
}

Value integratedTest2(const Array& params, bool fHelp)
{
    if(fHelp || params.size() > 0)
        throw runtime_error(
            "integratedTest2 no args"
            + HelpRequiringPassphrase());

    fs::create_directories("/home/argon/data1/testnet/state");
    fs::permissions("/home/argon/data1/testnet/state", fs::owner_all);
    std::unique_ptr<dev::db::DatabaseFace> db = dev::db::DBFactory::create("/home/argon/data1/testnet/state");
    std::unordered_map<dev::Address, dev::eth::Account> m_cache;

    state.init();
    std::cout << "state root before test insert " << state.root() << std::endl;
    dev::Address tmpAddr("1234567890123456789012345678901234567890");
    dev::eth::Account tmpAcc(0,0);
    std::cout << "tmpAcc created storageRoot " << tmpAcc.baseRoot() << std::endl;
    namespace po = boost::program_options;
    po::options_description desc("Allowed options");
    desc.add_options()
    ("key1", po::value<dev::u256>()->value_name("<v1>"), "hljhkljh")
    ("val1", po::value<dev::u256>()->value_name("<v2>"), "hljhkljh");
    po::variables_map m;
    int arg_count = 3;
    char* args[] = {
        "program",
        "--key1=123",
        "--val1=456"
    };

    po::parsed_options parsed = po::parse_command_line(arg_count, args, desc);
    po::store(parsed, m);
    po::notify(m);

    if(m.count("key1")) std::cout << "key1" << std::endl;
    if(m.count("key2")) std::cout << "key2" << std::endl;

    dev::u256 key1 =
        m["key1"].as<dev::u256>();
    dev::u256 val1 =
        m["val1"].as<dev::u256>();
    dev::RLPStream s(4);
    tmpAcc.setStorage(key1, val1);
    std::cout << "tmpAcc storage set - storageRoot " << tmpAcc.baseRoot() << std::endl;
    dev::SpecificTrieDB<dev::FatGenericTrieDB<dev::OverlayDB>, dev::FixedHash<20> >::iterator iter = state.begin();
    {
        dev::u256 nonce = 12345678;
        dev::u256 balance = 1010101010101;
        s << nonce << balance;

        std::cout << nonce << std::endl;
        {
            dev::SecureTrieDB<dev::h256, dev::StateCacheDB> storageDB(state.db(), tmpAcc.baseRoot());
            for(auto i : tmpAcc.storageOverlay())
            {
                std::cout << "test 2 insert" << std::endl;
                storageDB.insert(i.first, dev::rlp(i.second));
            }
            s << storageDB.root();
            std::cout << "generated storage root " << storageDB.root() << std::endl;
        }

        std::cout << "insert tmpAddr into state" << std::endl;
        s << tmpAcc.codeHash();
        std::cout << "appended codehash " << tmpAcc.codeHash() << std::endl;
        std::cout << "s.out vector unsigned char " << s.out().size() << std::endl;


        state.insert(tmpAddr, &s.out());
        dev::RLP rlp_state_(s.out(),0);
        auto const nonce_ = rlp_state_[0].toInt<dev::u256>();

        auto const balance_ = rlp_state_[1].toInt<dev::u256>();
        auto const storageRoot_ = rlp_state_[2].toHash<dev::h256>();
        auto const codeHash_ = rlp_state_[3].toHash<dev::h256>();
    }

    overlayDB_.commit();
    string account_str = state.at(tmpAddr);
    dev::h256 storageRoot__("650276fe18bc32afd3f79fc876c678269635c037e52f178402cfaf1a0c6ea911");

    dev::Address tmpAddr2("9299567890123456789012345678901234567890");
    string account_str2 = state.at(tmpAddr2);
    std::cout << "read back account string from trie " << account_str << std::endl;
    dev::RLP rlp_state(s.out(),0);
    std::cout << "constructed rlp" << std::endl;
    auto const nonce = rlp_state[0].toInt<dev::u256>();
    std::cout << "extracted nonce " << nonce << std::endl;
    auto const balance = rlp_state[1].toInt<dev::u256>();
    std::cout << "extracted balance " << balance << std::endl;
    auto const storageRoot = rlp_state[2].toHash<dev::h256>();
    std::cout << "extracted storageRoot " << storageRoot << std::endl;
    auto const codeHash = rlp_state[3].toHash<dev::h256>();
    std::cout << "extracted codeHash " << codeHash << std::endl;
    fs::path configFile = "/home/argon/rem/CC/testdata/rlp/transaction.rlp";

    vector<Value> res;
    return res;
}

Value integratedTest3(const Array& params, bool fHelp)
{
    if(fHelp || params.size() > 0)
        throw runtime_error(
            "integratedTest3 no args"
            + HelpRequiringPassphrase());

    std::unique_ptr<dev::db::DatabaseFace> db = dev::db::DBFactory::create("/home/argon/data1/testnet/state");
    dev::h256 root("ac7ed96f9c8ced36cb005661a0083cd2284e1487c578e4ffbfa4f2550fcfd947");


    dev::SecureTrieDB<dev::Address, dev::OverlayDB> state(overlayDB_);

    state.setRoot(root);
    std::cout << "integratedTest3 state root after db open " << state.root() << std::endl;
    std::unordered_map<dev::Address, dev::eth::Account> m_cache;
    std::ostringstream os;
    state.debugStructure(os);
    std::cout << "trie op << " << os.str() << std::endl;

    std::cout << "state root after retrieving from db " << state.root() << std::endl;
    dev::Address tmpAddr("1234567890123456789012345678901234567890");
    string account_str = state.at(tmpAddr);
    dev::RLP rlp_state(account_str,0);
    auto const nonce = rlp_state[0].toInt<dev::u256>();
    auto const balance = rlp_state[1].toInt<dev::u256>();
    auto const storageRoot = rlp_state[2].toHash<dev::h256>();
    auto const codeHash = rlp_state[3].toHash<dev::h256>();

    dev::eth::Account retrievedAcc(nonce,balance,storageRoot,codeHash,0,dev::eth::Account::Unchanged);
    {
        map<dev::h256, pair<dev::u256, dev::u256>> ret;

        {
            if (dev::h256 root = retrievedAcc.baseRoot())
            {
                //trans set  - test case - cast
                dev::SecureTrieDB<dev::h256, dev::OverlayDB> memdb(const_cast<dev::OverlayDB*>(overlayDB_), root);


                //trans set  - test case - recon
                for (auto it = memdb.hashedBegin(); it != memdb.hashedEnd(); ++it)
                {
                    dev::h256 const hashedKey((*it).first);
                    dev::u256 const key = dev::h256(it.key());
                    dev::u256 const value = dev::RLP((*it).second).toInt<dev::u256>();
                    ret[hashedKey] = make_pair(key, value);
                }
            }

            for (auto const& i : retrievedAcc.storageOverlay())
            {
                dev::h256 const key = i.first;
                dev::h256 const hashedKey = sha3(key);
                if (i.second)
                    ret[hashedKey] = i;
                else
                    ret.erase(hashedKey);
            }
        }

        for(auto i : ret)
        {
            pair<dev::u256,dev::u256> val = i.second;
        }
    }
    vector<Value> res;
    return res;
}


Value integratedTest4(const Array& params, bool fHelp)
{
    if(fHelp || params.size() > 0)
        throw runtime_error(
            "integratedTest4 no args"
            + HelpRequiringPassphrase());

    CPubKey newKey_contract_address;
    if(!pwalletMain->GetKeyFromPool(newKey_contract_address, false))
        throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, "Error: Keypool ran out, please call keypoolrefill first");
    CKeyID keyID_contract_address = newKey_contract_address.GetID();
    dvmc::address create_address = dvmc::literals::internal::from_hex<dvmc::address>(keyID_contract_address.GetHex().c_str());

    CPubKey newKey_test_sender_address;
    if(!pwalletMain->GetKeyFromPool(newKey_test_sender_address, false))
        throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, "Error: Keypool ran out, please call keypoolrefill first");
    CKeyID keyID_test_sender_address = newKey_test_sender_address.GetID();
    dvmc::address test_sender_address = dvmc::literals::internal::from_hex<dvmc::address>(keyID_test_sender_address.GetHex().c_str());

    dvmc::address test_recipient_address = test_sender_address;

    std::cout << "integratedTest4 : initialised create address " << dvmc::hex(create_address.bytes) << "\n";
    std::cout << "integratedTest4 : initialised from address " << dvmc::hex(test_sender_address.bytes) << "\n";
    std::cout << "integratedTest4 : initialised to address " << dvmc::hex(test_recipient_address.bytes) << "\n";
    const auto code = dvmc::from_hex(erc20_22112022_withdraw_with_parameter_subtract_15);

    dvmc::VertexNode host;
    dvmc::TransitionalNode created_account;
    dvmc::TransitionalNode sender_account;
    sender_account.set_balance(3141);
    dvmc_message msg{};
    msg.track = std::numeric_limits<int64_t>::max();

    dvmc::bytes_view exec_code = code;
    {
        dvmc_message create_msg{};
        create_msg.kind = DVMC_CREATE;
        create_msg.recipient = create_address;
        create_msg.track = std::numeric_limits<int64_t>::max();

        dvmc_revision rev = DVMC_LATEST_STABLE_REVISION;
        dvmc::VM vm = dvmc::VM{dvmc_create_dvmone()};
        const auto create_result = vm.retrieve_desc_vx(host, rev, create_msg, code.data(), code.size());
        if (create_result.status_code != DVMC_SUCCESS)
        {
            std::cout << "integratedTest4 : Contract creation failed: " << create_result.status_code << "\n";
            return create_result.status_code;
        }

        auto& created_account = host.accounts[create_address];
        created_account.set_balance(100000000000000);
        created_account.code = dvmc::bytes(create_result.output_data, create_result.output_size);

        msg.recipient = create_address;
        exec_code = created_account.code;
    }
    {
        std::cout << "\n";
        const auto input = dvmc::from_hex("0x18160ddd");
        msg.input_data = input.data();
        msg.input_size = input.size();

        dvmc_revision rev = DVMC_LATEST_STABLE_REVISION;
        dvmc::VM vm = dvmc::VM{dvmc_create_dvmone()};
        const auto result = vm.retrieve_desc_vx(host, rev, msg, exec_code.data(), exec_code.size());

        const auto track_used = msg.track - result.track_left;
        std::cout << "4: Result: totalSupply  " << result.status_code << "\nTrack used: " << track_used << "\n";
    }
    {
        std::cout << "\n";
        const auto input = dvmc::from_hex("0x42966c68000000000000000000000000000000000000000000000000000000000000029a");
        msg.input_data = input.data();
        msg.input_size = input.size();

        dvmc_revision rev = DVMC_LATEST_STABLE_REVISION;
        dvmc::VM vm = dvmc::VM{dvmc_create_dvmone()};
        const auto result = vm.retrieve_desc_vx(host, rev, msg, exec_code.data(), exec_code.size());
        const auto track_used = msg.track - result.track_left;
        std::cout << " : Result: Burn  " << result.status_code << "\nTrack used: " << track_used << "\n";
    }
    {
        std::cout << "\n";
        const auto input = dvmc::from_hex("0x18160ddd");
        msg.input_data = input.data();
        msg.input_size = input.size();

        dvmc_revision rev = DVMC_LATEST_STABLE_REVISION;
        dvmc::VM vm = dvmc::VM{dvmc_create_dvmone()};
        const auto result = vm.retrieve_desc_vx(host, rev, msg, exec_code.data(), exec_code.size());
        const auto track_used = msg.track - result.track_left;
        std::cout << " : Result: totalSupply  " << result.status_code << "\nTrack used: " << track_used << "\n";

        if (result.status_code == DVMC_SUCCESS || result.status_code == DVMC_REVERT)
            std::cout << " : Output:   " << dvmc::hex({result.output_data, result.output_size}) << "\n";
    }
    {
        std::string s = dvmc::hex(test_sender_address.bytes);
        const std::string code_str = "0x095ea7b3000000000000000000000000" + s +  "0000000000000000000000000000000000000000000000000000000000000050";
        std::cout << "approve op input code " << code_str << std::endl;
        const auto input = dvmc::from_hex(code_str);
        msg.sender = test_sender_address;
        msg.input_data = input.data();
        msg.input_size = input.size();

        dvmc_revision rev = DVMC_LATEST_STABLE_REVISION;
        dvmc::VM vm = dvmc::VM{dvmc_create_dvmone()};
        const auto result = vm.retrieve_desc_vx(host, rev, msg, exec_code.data(), exec_code.size());
        const auto track_used = msg.track - result.track_left;
        std::cout << "integratedTest4 : Result:   " << result.status_code << "\nTrack used: " << track_used << "\n";
    }
    {
        std::cout << "\n";
        std::string s = dvmc::hex(test_sender_address.bytes);
        std::string code_str = "0xdd62ed3e000000000000000000000000" + s + "000000000000000000000000" + s;
        std::cout << "print allowance op input code " << code_str << std::endl;
        const auto input = dvmc::from_hex(code_str);
        msg.input_data = input.data();
        msg.input_size = input.size();

        dvmc_revision rev = DVMC_LATEST_STABLE_REVISION;
        dvmc::VM vm = dvmc::VM{dvmc_create_dvmone()};
        const auto result = vm.retrieve_desc_vx(host, rev, msg, exec_code.data(), exec_code.size());
        const auto track_used = msg.track - result.track_left;
        std::cout << "integratedTest4 : Result:   " << result.status_code << "\nTrack used: " << track_used << "\n";
        if (result.status_code == DVMC_SUCCESS || result.status_code == DVMC_REVERT)
            std::cout << "integratedTest4 : Output:   " << dvmc::hex({result.output_data, result.output_size}) << "\n";
    }
    {
        std::cout << "\n";
        std::string s = dvmc::hex(test_sender_address.bytes);
        std::string code_str = "0x23b872dd000000000000000000000000" + s + "000000000000000000000000" + s + "0000000000000000000000000000000000000000000000000000000000000037";
        std::cout << "transfer_from op input code " << code_str << std::endl;
        const auto input = dvmc::from_hex(code_str);

        msg.track = std::numeric_limits<int64_t>::max();
        msg.input_data = input.data();
        msg.input_size = input.size();

        dvmc_revision rev = DVMC_LATEST_STABLE_REVISION;
        dvmc::VM vm = dvmc::VM{dvmc_create_dvmone()};
        const auto result = vm.retrieve_desc_vx(host, rev, msg, exec_code.data(), exec_code.size());

        const auto track_used = msg.track - result.track_left;
        std::cout << " : Result: transfer_from  " << result.status_code << "\nTrack used: " << track_used << "\n";
        if (result.status_code == DVMC_SUCCESS || result.status_code == DVMC_REVERT)
            std::cout << "integratedTest4 : Output:   " << dvmc::hex({result.output_data, result.output_size}) << "\n";

    }
    {
        std::cout << "\n";
        std::string s = dvmc::hex(test_sender_address.bytes);
        std::string code_str = "0xdd62ed3e000000000000000000000000" + s + "000000000000000000000000" + s;
        std::cout << "print allowance op input code " << code_str << std::endl;
        const auto input = dvmc::from_hex(code_str);
        msg.input_data = input.data();
        msg.input_size = input.size();

        dvmc_revision rev = DVMC_LATEST_STABLE_REVISION;
        dvmc::VM vm = dvmc::VM{dvmc_create_dvmone()};
        const auto result = vm.retrieve_desc_vx(host, rev, msg, exec_code.data(), exec_code.size());
        const auto track_used = msg.track - result.track_left;
        std::cout << " : Result:   " << result.status_code << "\nTrack used: " << track_used << "\n";
        if (result.status_code == DVMC_SUCCESS || result.status_code == DVMC_REVERT)
            std::cout << " : Output: allowance  " << dvmc::hex({result.output_data, result.output_size}) << "\n";
    }


    vector<Value> res;
    return res;
}



